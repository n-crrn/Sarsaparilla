@page "/applied-pi"

@*
 * Demonstration of the SarsaWidgets used for the Applied Pi related matters.
 *@

@using AppliedPi
@using SarsaWidgets

<section>
    <h2>Applied Pi Editor</h2>
    <p>Blank:</p>
    <AppliedPiEditor/>
    <p>Preset text:</p>
    <AppliedPiEditor Text=@PiNetworkTestSource/>
</section>

<section>
    <h2>Network Display</h2>
    <NetworkDisplay Network=@TestNetwork/>
</section>

<section>
    <h2>Resolved Network Display</h2>

    <ResolvedNetworkDisplay SourceNetwork=ResolveTestNw ResolvedNetwork=ResolveTestResolvedNw/>
</section>

@code {
    private static readonly string PiNetworkTestSource =
            "free A, B, C: channel.\n" +
            "free D: kitten [private].\n" +
            "type kitten.\n" +
            "type (* Random comment *) dog.\n" +
            "type host.\n" +
            "event beginB(host, host).\n" +
            "event endB(host, host).\n" +
            "(* Another surprise comment. *)\n" +
            "fun pk(skey): pkey.\n" +
            "fun sencrypt(bitstring,nonce): bitstring.\n" +
            "reduc forall x: bitstring, y: skey; decrypt(encrypt(x, y),y) = x.\n" +
            "table keys(host, pkey).\n" +
            "query attacker(D).\n" +
            "const c1: tag [data].\n" +
            "\n" +
            "let procA(hostA: host) = out(c, D).\n" +
            "\n" +
            "process\n" +
            "    let h: channel = if X = A then A else C in\n" +
            "    if h <> A && h <> B then\n" +
            "        out(A, host).";

    private readonly Network TestNetwork = Network.CreateFromCode(PiNetworkTestSource);

    private static readonly string ResolvedPiNetworkTestSource =
        @"(* Full test of calling processings. *)
free c: channel.
type key.
fun encrypt(bitstring, key): bitstring.
reduc forall x: bitstring, y: key; decrypt(encrypt(x, y),y) = x.
event gotValue(bitstring).
event anotherValue(bool).
const Good: bitstring.

(* Sub-processes *)
let rx(k: key) = in(c, value: bitstring);
                 let x: bitstring = decrypt(value, k) in event gotValue(x) else event gotValue(Good).
let send(k: key) = out(c, encrypt(Good, k));
                   in(c, z: bool);
                   if z then event anotherValue(z) else out(c, z).

(* Main *)
process
    new kValue: key;
    (! send(kValue) | ! rx(kValue)).";

    private readonly Network ResolveTestNw;

    private readonly ResolvedNetwork ResolveTestResolvedNw;

    public AppliedPiPage()
    {
        ResolveTestNw = Network.CreateFromCode(ResolvedPiNetworkTestSource);
        ResolveTestResolvedNw = ResolvedNetwork.From(ResolveTestNw);
    }
}
