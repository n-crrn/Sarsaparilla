@page "/"

@* 
 * The page dedicated to directly editing and processing Stateful Horn clauses.
 * Note that this page will require heavy refactoring to remove redundant code,
 * as a lot of this work is experimental.
 *@

@using System.IO
@using System.Text
@using StatefulHorn
@using SarsaWidgets

@inject IJSRuntime JS

<PageTitle>Stateful Horn Clause Authoring</PageTitle>

<PaneStack>
    <Pane Title="Stateful Horn Editor">
        <ButtonBarItems>
            <button class='parse-button' @onclick=Parse>Parse</button>
        </ButtonBarItems>
        <Body>
            <div class='outer-pane'>
                <div class='pane-button-bar'>
                    <button class='load-source-file'>
                        <InputFile OnChange=@LoadSourceFile/>
                        <div class='load-source-file-inner'>📂 Load Source File</div>
                    </button>
                    <div class='grower'></div>
                    <button @onclick=LoadBasicExample>Load Basic Example</button>
                    <button @onclick=LoadPaperExample1>Load Paper Example 1</button>
                    <button @onclick=LoadPaperExample2>Load Paper Example 2</button>
                    <div class='grower'></div>
                    <button @onclick=SaveSource>💾 Save Source</button>
                </div>
                <div class='pane-body'>
                    <ClauseEditor @bind-Text=StatefulHornSource/>
                </div>
            </div>
        </Body>
    </Pane>

    <Pane Title='Compilation &amp; Elaboration'>
        <ButtonBarItems>
            <button disabled=@(NotParsed || (Universe != null && Universe.IsExhausted)) @onclick=Elaborate>Elaborate</button>
        </ButtonBarItems>
        <Body>
            <div class='elaboration-pane-inner'>
                <div class='elaboration-column'>
                    <button disabled=@NotParsed @onclick=ExportBasisRules>Export Basis Rules</button>
                    <ClauseCompileDisplay Compiler=Compiler/>
                </div>
                @if (Universe != null)
                {
                    <div class='elaboration-column'>
                        <div class='pane-button-bar'>
                            <button disabled=@NotParsed @onclick=ExportElaborations>Export All</button>
                            <select class='grower' disabled=@NotParsed @bind=GenerationViewed>
                                <option value='0'>Basis Rules</option>
                                @for (int i = 1; i < Universe.ChangeLog.Count; i++)
                                {
                                    <option value='@i'>Generation @i</option>
                                }
                            </select>
                        </div>
                        @if (Universe.ChangeLog[GenerationViewed].Count == 0)
                        {
                            <div class='empty-generation-message'>
                                There were no further rules created in this generation.
                            </div>
                        }
                        else
                        {
                            <RuleChangeSetDisplay Entries=Universe.ChangeLog[GenerationViewed]/>
                        }
                    </div>
                }
            </div>
        </Body>
    </Pane>

    <Pane Title='Ruleset Inspection &amp; Querying'>
        <Body>
            <div class='outer-pane'>
                <div class='pane-button-bar'>
                    <button disabled=@NotParsed @onclick=ExportRuleSet>Export Ruleset</button>
                    <div class='grower'>
                        <RuleFilterInput Disabled=@NotParsed @bind-Filter=QueryFilter />
                    </div>
                </div>
                <div class='pane-body'>
                    @if (NotParsed)
                    {
                        <div class='empty-pane-message'>
                            <div class='empty-pane-message-inner'>
                                Click "Parse" in the Editor Pane and "Elaborate" in the Elaboration Pane to query
                                generated rulesets here.
                            </div>
                        </div>
                    }
                    else if (Universe != null)
                    {
                        <div class='rule-set-query-pane-column'>
                            <RuleSetDisplay Universe=Universe Filter=QueryFilter />
                        </div>
                    }
                </div>
            </div>
        </Body>
    </Pane>
</PaneStack>

@code {
    public Index()
    {
        Compiler.OnComplete += (IClauseCompiler cc, Universe u) => Universe = u;
    }

    #region Clause source handling.

    public string StatefulHornSource { get; set; } = "";

    public bool NotParsed { get; set; } = true;

    private async void LoadSourceFile(InputFileChangeEventArgs args)
    {
        try
        {
            using StreamReader reader = new(args.File.OpenReadStream());
            StatefulHornSource = await reader.ReadToEndAsync();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            StatefulHornSource = $"// UNABLE TO LOAD SOURCE: {ex}";
        }
    }

    private void Parse() 
    {
        NotParsed = false;
        Compiler.Compile(StatefulHornSource);
        GenerationViewed = 0;
    }

    private void ResetWithCode(string src) 
    {
        StatefulHornSource = src;
        NotParsed = true;
    }

    public void LoadBasicExample() => ResetWithCode(SampleLibrary.Basic);

    public void LoadPaperExample1() => ResetWithCode(SampleLibrary.PaperExample1);

    public void LoadPaperExample2() => ResetWithCode(SampleLibrary.PaperExample2);

    private static readonly string DefaultSourceFilename = "source.txt";

    public async void SaveSource()
    {
        await SaveStringToFile(DefaultSourceFilename, StatefulHornSource);
    }

    #endregion
    #region Basic compilation.

    private ClauseCompiler Compiler = new();

    private Universe? Universe;

    private static readonly string SaveFromStreamJSFunc = "saveFromStream";

    private static readonly string DefaultBasisRulesFilename = "basis-rules.txt";

    private async void ExportBasisRules()
    {
        if (Universe != null) {
            StringBuilder buffer = new();
            foreach (Rule r in Universe.BasisRules)
            {
                buffer.Append(r.ToString());
                buffer.Append("\n");
            }
            await SaveStringToFile(DefaultBasisRulesFilename, buffer.ToString());
        }
    }

    private UTF8Encoding Utf8 = new();

    private async Task SaveStringToFile(string filename, string data)
    {
        using MemoryStream memStream = new(Utf8.GetBytes(data));
        using DotNetStreamReference dnStreamRef = new(memStream);
        await JS.InvokeVoidAsync(SaveFromStreamJSFunc, filename, dnStreamRef);
    }

    #endregion
    #region Elaboration.

    private void Elaborate()
    {
        if (Universe != null) 
        {
            Universe.GenerateNextRuleSet();
            GenerationViewed = Universe!.ChangeLog.Count - 1;
        }
    }

    private int GenerationViewed { get; set; } = 0;

    private static readonly string DefaultElaborationFilename = "rule-elaboration.txt";

    private async Task ExportElaborations() {
        if (Universe != null)
        {
            StringBuilder buffer = new();
            WriteChangeLogEntries("Basis Rules", Universe.ChangeLog[0], buffer);
            for (int i = 1; i < Universe.ChangeLog.Count; i++)
            {
                WriteChangeLogEntries($"Elaboration {i}", Universe.ChangeLog[i], buffer);
            }
            await SaveStringToFile(DefaultElaborationFilename, buffer.ToString());
        }
    }

    private void WriteChangeLogEntries(string title, IEnumerable<Universe.ChangeLogEntry> entries, StringBuilder buffer)
    {
        buffer.Append($"// --- {title} ---\n");
        foreach (Universe.ChangeLogEntry entry in entries)
        {
            switch (entry.Decision)
            {
                case Universe.AddDecision.IsNew:
                    buffer.Append($"NEW: {entry.AttemptedRule}\n");
                    break;
                case Universe.AddDecision.IsImplied:
                    buffer.Append($"IMPLIED: {entry.AttemptedRule}\n");
                    buffer.Append("    …was instead implied by…\n");
                    buffer.Append($"    {entry.AffectedRules![0]}\n");
                    break;
                case Universe.AddDecision.ImpliesAnother:
                default:
                    buffer.Append($"IMPLIES OTHER: {entry.AttemptedRule}\n");
                    buffer.Append("    …implied, and therefore replaced, …\n");
                    foreach (Rule affected in entry.AffectedRules!)
                    {
                        buffer.Append($"    {affected}\n");
                    }
                    break;
            }
        }
    }

    #endregion
    #region Querying;

    private RuleFilter QueryFilter { get; set; } = new();

    private static readonly string DefaultRuleSetFilename = "rule-set.txt";

    private async void ExportRuleSet()
    {
        if (Universe != null) 
        {
            StringBuilder buffer = new();
            foreach (StateConsistentRule scr in Universe.ConsistentRules)
            {
                buffer.Append(scr.ToString() + "\n");
            }
            foreach (StateTransferringRule str in Universe.TransferringRules)
            {
                buffer.Append(str.ToString() + "\n");
            }
            await SaveStringToFile(DefaultRuleSetFilename, buffer.ToString());
        }
    }

    #endregion

}
