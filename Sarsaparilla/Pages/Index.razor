@page "/"

@* 
 * The page dedicated to directly editing and processing Stateful Horn clauses.
 * Note that this page will require heavy refactoring to remove redundant code,
 * as a lot of this work is experimental.
 *@

@using System.IO
@using System.Text
@using StatefulHorn
@using SarsaWidgets

@inject IJSRuntime JS

<PageTitle>Stateful Horn Clause Authoring</PageTitle>

<div class='pane-container'>
    <div class='pane-title'>
        <h2>Stateful Horn Editor</h2>
        <div class='button-bar-section'>
            <button @onclick=@(() => EditorPaneOpen = !EditorPaneOpen)>🗕</button>
            <button @onclick=MaximiseEditorPane>🗖</button>
        </div>
        <div class='button-bar-section'>
            <button class='parse-button' @onclick=Parse>Parse</button>
        </div>
    </div>
    <div class='@EditorPaneStateClass'>
        <div class='pane-button-bar'>
            <button class='load-source-file'>
                <InputFile OnChange=@LoadSourceFile/>
                <div class='load-source-file-inner'>📂 Load Source File</div>
            </button>
            <div class='grower'></div>
            <button @onclick=LoadBasicExample>Load Basic Example</button>
            <button @onclick=LoadPaperExample1>Load Paper Example 1</button>
            <button @onclick=LoadPaperExample2>Load Paper Example 2</button>
            <div class='grower'></div>
            <button @onclick=SaveSource>💾 Save Source</button>
        </div>
        <div class='pane-body'>
            <ClauseEditor @bind-Text=StatefulHornSource/>
        </div>
    </div>

    <div class='pane-title'>
        <h2>Compilation &amp; Elaboration</h2>
        <div class='button-bar-section'>
            <button @onclick=@(() => ElaborationPaneOpen = !ElaborationPaneOpen)>🗕</button>
            <button @onclick=MaximiseElaborationPane>🗖</button>
        </div>
        <div class='button-bar-section'>
            <button disabled=@NotParsed @onclick=Elaborate>Elaborate</button>
        </div>
    </div>
    <div class='@ElaborationPaneStateClass'>
        <div class='pane-body'>
            <div class='elaboration-pane-inner'>
                <div class='elaboration-column'>
                    <button disabled=@NotParsed @onclick=ExportBasisRules>Export Basis Rules</button>
                    <ClauseCompileDisplay Compiler=Compiler/>
                </div>
                @if (Universe != null)
                {
                    <div class='elaboration-column'>
                        <div class='pane-button-bar'>
                            <button disabled=@NotParsed @onclick=ExportElaborations>Export All</button>
                            <select class='grower' disabled=@NotParsed @bind=GenerationViewed>
                                <option value='0'>Basis Rules</option>
                                @for (int i = 1; i < Universe.ChangeLog.Count; i++)
                                {
                                    <option value='@i'>Generation @i</option>
                                }
                            </select>
                        </div>
                        <RuleChangeSetDisplay Entries=Universe.ChangeLog[GenerationViewed]/>
                    </div>
                }
            </div>
        </div>
    </div>

    <div class='pane-title'>
        <h2>Ruleset Inspection and Querying</h2>
        <div class='button-bar-section'>
            <button @onclick=@(() => RuleSetQueryPaneOpen = !RuleSetQueryPaneOpen)>🗕</button>
            <button @onclick=MaximiseRuleSetQueryPane>🗖</button>
        </div>
    </div>
    <div class='@RuleSetQueryPaneStateClass'>
        <div class='pane-button-bar'>
            <button disabled=@NotParsed @onclick=ExportRuleSet>Export Ruleset</button>
            <div class='grower'>
                <RuleFilterInput Disabled=@NotParsed @bind-Filter=QueryFilter />
            </div>
        </div>
        <div class='pane-body'>
            @if (NotParsed)
            {
                <div class='empty-pane-message'>
                    <div class='empty-pane-message-inner'>
                        Click "Parse" in the Editor Pane and "Elaborate" in the Elaboration Pane to query
                        generated rulesets here.
                    </div>
                </div>
            }
            else if (Universe != null)
            {
                <div class='rule-set-query-pane-column'>
                    <RuleSetDisplay Universe=Universe Filter=QueryFilter />
                </div>
            }
        </div>
    </div>

</div>

@code {
    public Index()
    {
        Compiler.OnComplete += (IClauseCompiler cc, Universe u) => Universe = u;
    }

    #region Clause source handling.

    public string StatefulHornSource { get; set; } = "";

    public bool NotParsed { get; set; } = true;

    private async void LoadSourceFile(InputFileChangeEventArgs args)
    {
        try
        {
            using StreamReader reader = new(args.File.OpenReadStream());
            StatefulHornSource = await reader.ReadToEndAsync();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            StatefulHornSource = $"// UNABLE TO LOAD SOURCE: {ex}";
        }
    }

    private void Parse() 
    {
        NotParsed = false;
        Compiler.Compile(StatefulHornSource);
        ElaborationPaneOpen = true;
    }

    private void ResetWithCode(string src) 
    {
        StatefulHornSource = src;
        NotParsed = true;
    }

    public void LoadBasicExample() => ResetWithCode(SampleLibrary.Basic);

    public void LoadPaperExample1() => ResetWithCode(SampleLibrary.PaperExample1);

    public void LoadPaperExample2() => ResetWithCode(SampleLibrary.PaperExample2);

    private static readonly string DefaultSourceFilename = "source.txt";

    public async void SaveSource()
    {
        await SaveStringToFile(DefaultSourceFilename, StatefulHornSource);
    }

    #endregion
    #region Pane management.

    public static readonly string OpenPaneCSSClass = "open-pane";
    public static readonly string ShutPaneCSSClass = "shut-pane";

    private string EditorPaneStateClass = OpenPaneCSSClass;

    public bool EditorPaneOpen 
    {
        get => EditorPaneStateClass == OpenPaneCSSClass;
        set => EditorPaneStateClass = value ? OpenPaneCSSClass : ShutPaneCSSClass;
    }

    private string ElaborationPaneStateClass = OpenPaneCSSClass;

    public bool ElaborationPaneOpen
    {
        get => ElaborationPaneStateClass == OpenPaneCSSClass;
        set => ElaborationPaneStateClass = value ? OpenPaneCSSClass : ShutPaneCSSClass;
    }

    private string RuleSetQueryPaneStateClass = OpenPaneCSSClass;

    public bool RuleSetQueryPaneOpen
    {
        get => RuleSetQueryPaneStateClass == OpenPaneCSSClass;
        set => RuleSetQueryPaneStateClass = value ? OpenPaneCSSClass : ShutPaneCSSClass;
    }

    private void SetAllPaneStatuses(bool editorOpen, bool elaborationOpen, bool queryOpen) {
        EditorPaneOpen = editorOpen;
        ElaborationPaneOpen = elaborationOpen;
        RuleSetQueryPaneOpen = queryOpen;
    }

    private void MaximiseEditorPane() => SetAllPaneStatuses(true, false, false);
    private void MaximiseElaborationPane() => SetAllPaneStatuses(false, true, false);
    private void MaximiseRuleSetQueryPane() => SetAllPaneStatuses(false, false, true);

    #endregion
    #region Basic compilation.

    private ClauseCompiler Compiler = new();

    private Universe? Universe;

    private static readonly string SaveFromStreamJSFunc = "saveFromStream";

    private static readonly string DefaultBasisRulesFilename = "basis-rules.txt";

    private async void ExportBasisRules()
    {
        if (Universe != null) {
            StringBuilder buffer = new();
            foreach (Rule r in Universe.BasisRules)
            {
                buffer.Append(r.ToString());
                buffer.Append("\n");
            }
            await SaveStringToFile(DefaultBasisRulesFilename, buffer.ToString());
        }
    }

    private UTF8Encoding Utf8 = new();

    private async Task SaveStringToFile(string filename, string data)
    {
        using MemoryStream memStream = new(Utf8.GetBytes(data));
        using DotNetStreamReference dnStreamRef = new(memStream);
        await JS.InvokeVoidAsync(SaveFromStreamJSFunc, filename, dnStreamRef);
    }

    #endregion
    #region Elaboration.

    private void Elaborate()
    {
        if (Universe != null) 
        {
            Universe.GenerateNextRuleSet();
            GenerationViewed = Universe!.ChangeLog.Count - 1;
        }
    }

    private int GenerationViewed { get; set; } = 0;

    private static readonly string DefaultElaborationFilename = "rule-elaboration.txt";

    private async Task ExportElaborations() {
        if (Universe != null)
        {
            StringBuilder buffer = new();
            WriteChangeLogEntries("Basis Rules", Universe.ChangeLog[0], buffer);
            for (int i = 1; i < Universe.ChangeLog.Count; i++)
            {
                WriteChangeLogEntries($"Elaboration {i}", Universe.ChangeLog[i], buffer);
            }
            await SaveStringToFile(DefaultElaborationFilename, buffer.ToString());
        }
    }

    private void WriteChangeLogEntries(string title, IEnumerable<Universe.ChangeLogEntry> entries, StringBuilder buffer)
    {
        buffer.Append($"// --- {title} ---\n");
        foreach (Universe.ChangeLogEntry entry in entries)
        {
            switch (entry.Decision)
            {
                case Universe.AddDecision.IsNew:
                    buffer.Append($"NEW: {entry.AttemptedRule}\n");
                    break;
                case Universe.AddDecision.IsImplied:
                    buffer.Append($"IMPLIED: {entry.AttemptedRule}\n");
                    buffer.Append("    …was instead implied by…\n");
                    buffer.Append($"    {entry.AffectedRules![0]}\n");
                    break;
                case Universe.AddDecision.ImpliesAnother:
                default:
                    buffer.Append($"IMPLIES OTHER: {entry.AttemptedRule}\n");
                    buffer.Append("    …implied, and therefore replaced, …\n");
                    foreach (Rule affected in entry.AffectedRules!)
                    {
                        buffer.Append($"    {affected}\n");
                    }
                    break;
            }
        }
    }

    #endregion
    #region Querying;

    private RuleFilter QueryFilter { get; set; } = new();

    private static readonly string DefaultRuleSetFilename = "rule-set.txt";

    private async void ExportRuleSet()
    {
        if (Universe != null) 
        {
            StringBuilder buffer = new();
            foreach (StateConsistentRule scr in Universe.ConsistentRules)
            {
                buffer.Append(scr.ToString() + "\n");
            }
            foreach (StateTransferringRule str in Universe.TransferringRules)
            {
                buffer.Append(str.ToString() + "\n");
            }
            await SaveStringToFile(DefaultRuleSetFilename, buffer.ToString());
        }
    }

    #endregion

}
